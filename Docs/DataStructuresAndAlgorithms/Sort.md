# 1. 排序算法分类

&emsp;&emsp;**在计算机科学所使用的排序算法通常被分类为:**

1. 计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是 O(nlogn)(大O符号)，坏的性能是 O(n^2)。对于一个排序理想的性能是 O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要 O(nlogn)。
2. 内存使用量（以及其他计算机资源的使用）。
3. 稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录 R和 S，且在原本的列表中 R出现在 S之前，在排序过的列表中 R也将会是在 S之前。
4. 依据排序的方法：插入、交换、选择、合并等等。

## 1.1 稳定性

&emsp;&emsp;稳定排序算法会依照相等的关键（换言之就是值）维持纪录的相对次序。也就是一个排序算法是稳定的，就是当有两个有相等关键的纪录R和S，且在原本的串行中R出现在S之前，在排序过的串行中R也将会是在S之前。

## 1.2 计算复杂度

- 依据串行（list）的大小（n），一般而言，好的表现是O(nlogn)，且坏的行为是O(n2)。对于一个排序理想的表现是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(nlogn)。
- 所有基于比较的排序的时间复杂度至少是 O(nlogn)。

## 1.3 常用排序算法

|  排序方法  | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 | 稳定性 |
| :--------: | :----------------: | :----------------: | :----------------: | :--------: | :----: |
|  冒泡排序  |       O(n^2)       |       O(n^2)       |        O(n)        |    O(1)    |  稳定  |
|  插入排序  |       O(n^2)       |       O(n^2)       |        O(n)        |    O(1)    |  稳定  |
|  选择排序  |       O(n^2)       |       O(n^2)       |       O(n^2)       |    O(1)    | 不稳定 |
|  快速排序  |      O(nlogn)      |       O(n^2)       |      O(nlogn)      |  O(nlogn)  | 不稳定 |
|  希尔排序  |      O(nlogn)      |       O(n^2)       |        O(n)        |    O(1)    | 不稳定 |
|   堆排序   |      O(nlogn)      |      O(nlogn)      |      O(nlogn)      |    O(1)    | 不稳定 |
|  归并排序  |      O(nlogn)      |      O(nlogn)      |      O(nlogn)      |    O(n)    |  稳定  |
| 二叉树排序 |      O(nlogn)      |      O(nlogn)      |      O(nlogn)      |    O(n)    |  稳定  |
|   桶排序   |       O(n+k)       |       O(n^2)       |        O(n)        |   O(n+k)   |  稳定  |
|  基数排序  |       O(n*k)       |       O(n*k)       |       O(n*k)       |   O(n+k)   |  稳定  |
|  计数排序  |       O(n+k)       |       O(n+k)       |       O(n+k)       |   O(n+k)   |  稳定  |

# 2. 常见排序算法

​	**常见的稳定排序算法有：**

- 冒泡排序（Bubble Sort） — O(n²)

- 插入排序（Insertion Sort）— O(n²)

- 桶排序（Bucket Sort）— O(n); 需要 O(k) 额外空间

- 计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间

- 合并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间

- 二叉排序树排序 （Binary tree sort） — O(n log n) 期望时间; O(n²)最坏时间; 需要 O(n) 额外空间

- 基数排序（Radix sort）— O(n·k); 需要 O(n) 额外空间

  **常见的不稳定排序算法有：**

- 选择排序（Selection Sort）— O(n²)

- 希尔排序（Shell Sort）— O(nlogn)

- 堆排序（Heapsort）— O(nlogn)

- 快速排序（Quicksort）— O(nlogn) 期望时间, O(n²) 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序

### 2.1 冒泡排序

- 冒泡排序（Bubble Sort）是最简单最容易理解的排序算法之一，它是基于比较的排序算法，其思想是通过无序区中相邻记录关键字间的比较和位置的交换,使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。

- 冒泡排序的复杂度：在最好情况下，即正序有序，则只需要比较n次，故为O(n) ；最坏情况下，即逆序有序，则需要比较(n-1)+(n-2)+……+1，故为O(n²)。

- 算法原理是相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成：

  1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
  3. 针对所有的元素重复以上的步骤，除了最后一个；
  4. 重复步骤1~3，直到排序完成。

- 乌龟和兔子：在冒泡排序中，最大元素的移动速度是最快的，哪怕一开始最大元素处于序列开头，也可以在一轮内层循环之后，移动到序列末尾。而对于最小元素，每一轮内层循环只能向前挪动一位，如果最小元素在序列末尾，就需要 n-1 次交换才能移动到序列开头。这两种类型的元素分别被称为兔子和乌龟。

- C代码实现

  ```c
  void bubble_sort(int *arr, int len)
  {
      int i, j;
      
      for (i = 0; i < len - 1; i++)
      {
          for (j = 0; j < len - 1; j++)
          {
              if (arr[j] > arr[j + 1])
              {
                  int temp = arr[j + 1];
                  arr[j + 1] = arr[j];
                  arr[j] = temp;
              }
          }
      }
  }
  ```

- 优化：在非最坏的情况下，冒泡排序过程中，可以检测到整个序列是否已经排序完成，进而可以避免掉后续的循环；

  ```c
  void bubble_sort(int *arr, int len)
  {
      bool flag = false;
      int i, j;
      
      for (i = 0; i < len - 1; i++)
      {
          for (j = 0; j < len - 1; j++)
          {
              if (arr[j] > arr[j + 1])
              {
                  flag = true;
                  int temp = arr[j + 1];
                  arr[j + 1] = arr[j];
                  arr[j] = temp;
              }
          }
          
          if(!flag)
              break;
      }
  }
  ```

- 进一步地，在每轮循环之后，可以确认，最后一次发生交换的位置之后的元素，都是已经排好序的，因此可以不再比较那个位置之后的元素，大幅度减少了比较的次数：

  ```c
  void bubble_sort(int *arr, int len)
  {
      int i, j, new, n = len;
      
      for (i = 0; i < len - 1; i++)
      {
          new = 0;
          for (j = 0; j < n - 1; j++)
          {
              if (arr[j] > arr[j + 1])
              {
                  int temp = arr[j + 1];
                  arr[j + 1] = arr[j];
                  arr[j] = temp;
                  new = j + 1;
              }
          }
          n = new;
          
          if(n == 0)
              break;
      }
  }
  ```

- 更进一步地，为了优化之前提到的乌龟和兔子问题，可以进行双向的循环，正向循环把最大元素移动到末尾，逆向循环把最小元素移动到最前，这种优化过的冒泡排序，被称为鸡尾酒排序：

  ```c
  void bubble_sort(int *arr, int len)
  {
      int j, begin = 0, end = len - 1;
  
      while(begin <= end)
      {
          int nbegin = end;
          int nend = begin;
  
          for(j = begin; j < end; j++)
          {
              if (arr[j] > arr[j + 1])
              {
                  int temp = arr[j + 1];
                  arr[j + 1] = arr[j];
                  arr[j] = temp;
                  nend = j + 1;
              }
          }
          end = nend - 1;
  
          for(j = end; j > begin - 1; j--)
          {
              if (arr[j] > arr[j + 1])
              {
                  int temp = arr[j + 1];
                  arr[j + 1] = arr[j];
                  arr[j] = temp;
                  nbegin = j;
              }
          }
          begin = nbegin + 1;
      }
  }
  ```

### 2.2 插入排序

+ 插入排序（Insertion-Sort）是一种简单直观的排序算法。通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

+ 插入排序的思想是，每次只处理一个元素，从后往前查找，找到该元素合适的插入位置，最好的情况下，即正序有序(从小到大)，这样只需要比较n次，不需要移动。因此时间复杂度为O(n) ，最坏的情况下，即逆序有序，这样每一个元素就需要比较n次，共有n个元素，因此实际复杂度为O(n²) 。

+ 算法原理：将数据分为两部分，有序部分与无序部分，一开始有序部分包含第1个元素，依次将无序的元素插入到有序部分，直到所有元素有序。插入排序又分为直接插入排序、二分插入排序、链表插入等，这里只讨论直接插入排序。它是稳定的排序算法，时间复杂度为O(n^2)。

+ 算法描述：
  1. 从第一个元素开始，该元素可以认为已经被排序；
  2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
  3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
  4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
  5. 将新元素插入到该位置后；
  6. 重复步骤2~5。

+ C代码实现：

  ```c
  void insertionSort(int *arr, int len)
  {
      int i = 1, j;
  
      while(i < len)
      {
          j = i;
          while(j > 0 && arr[j - 1] > arr[j])
          {
              int temp = arr[j];
              arr[j] = arr[j - 1];
              arr[j - 1] = temp;
              j--;
          }
          i++;
      }
  }
  ```

### 2.3 选择排序

+ 选择排序(Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 

+ 算法描述：n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：

  1. 初始状态：无序区为R[1..n]，有序区为空；
  2. 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
  3. n-1趟结束，数组有序化了。

+ C代码实现：

  ```c
  void selectSort(int *arr, int len)
  {
      int i, j, index;
  
      for(i = 0; i < len; i++)
      {
          index = i;
  
          for(j = i + 1; j < len; j++)
          {
              if(arr[j] < arr[index])
                  index = j;
          }
  
          if(index != i)
          {
              int temp = arr[i];
              arr[i] = arr[index];
              arr[index] = temp;
          }
      }
  }
  ```

### 2.4 快速排序

+ 快速排序（Quick Sort）是目前在实践中非常高效的一种排序算法，它不是稳定的排序算法，平均时间复杂度为O(nlogn)，最差情况下复杂度为O(n^2)。

+ 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

+ 算法复杂度：因为每次都将序列分为两个部分，故为 O(N * logN)；基本有序时，退化为冒泡排序，几乎要比较N*N次，故为O(N * N)。

+ 算法描述：快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

  1. 从数列中挑出一个元素，称为 “基准”（pivot）；
  2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

+ C代码实现：

  ```c
  void quickSort(int *arr, int left, int right)
  {
      if(left < right)
      {
          int i = left, j = right, target = arr[left];
  
          while(i < j)
          {
              while(i < j && arr[j] > target)
                  j--;
              if(i < j)
                  arr[i++] = arr[j];
  
              while(i < j && arr[i] < target)
                  i++;
              if(i < j)
                  arr[j] = arr[i];
          }
  
          arr[i] = target;
          quickSort(arr, left, i - 1);
          quickSort(arr, i + 1, right);
      }
  }
  ```

### 2.5 希尔排序

+ 希尔排序（Shell Sort）是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。

+ 算法描述：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

  1.  选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
  2.  按增量序列个数k，对序列进行k 趟排序；
  3.  每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

+ 时间复杂度：由于希尔排序的好坏和步长d的选择有很多关系，因此，目前还没有得出最好的步长如何选择。所以，不知道最好的情况下的算法时间复杂度。最坏情况下：O(N*logN)，最坏的情况下和平均情况下差不多。

+ 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

+ C代码实现：

  ```c
  void shellSort(int *arr, int len)
  {
      int i, j, d = len / 2;
  
      while(d > 0)
      {
          for(i = d; i < len; i++)
          {
              j = i - d;
              while(j >= 0 && arr[j] > arr[j + d])
              {
                  int temp = arr[j];
                  arr[j] = arr[j + d];
                  arr[j + d] = temp;
                  j = j - d;
              }
          }
  
          d = d / 2;
      }
  }
  ```

### 2.6 堆排序

### 2.7 归并排序

### 2.8 二叉树排序

### 2.9 桶式排序

### 2.10 

